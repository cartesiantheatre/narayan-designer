/*
    Narayan Designer, a modelling tool for the Narayan simulation engine.
    Copyright (C) 2017 Cartesian Theatre. All rights reserved.
*/

/*
    Invocation: $ bisonc++ --show-filenames --thread-safe NarayanLogicParser.ypp

    Generates:

        Baseclass header:       NarayanLogicParserBase.h    (not modifiable, clobbered / generated repeatedly in $builddir)
        Class header:           NarayanLogicParser.h        (user modifiable, preserved / generated once in $srcdir)
        Implementation header:  NarayanLogicParser.ih       (user modifiable, preserved / generated once in $srcdir)
        Parser implementation:  NarayanLogicParser.cpp      (not modifiable, clobbered / generated repeatedly in $builddir)
*/

// Bison declarations section contains declarations that define parser settings,
//  terminal and nonterminal symbols, their precedence and associativity, and so
//  forth...

    // Where to find the lexer...
    %scanner                    "NarayanLogicLexer.h"

    // What to call our lexer when it is declared...
    %scanner-class-name         NarayanLogicLexer
    
    // Lexer's method to tokenize...
    %scanner-token-function     d_scanner.lex()

    // What to name the parser class which contains the lexer as a member...
    %class-name                 NarayanLogicParser

    // Terminal tokens with associativity which determines how repeated uses of
    //  the given symbol nest, provided in order from lowest to highest
    //  precedence...
    %left                       '-' '+'
    %left                       '*' '/'
    %left                       '%'
    %right                      '^'         /* Exponentiation operator */
    %right                      UNARY       /* Positive or negation unary operator */

    // Define the parser's base class header file containing the parser's
    //  symbolic tokens...
    %baseclass-header           NarayanLogicParserBase.h

    // Define the name of source file containing the parser implementation...
    %parsefun-source            NarayanLogicParser.cpp

    // Define semantic value types using polymorphism instead of traditional
    //  union interface. This was added in bisonc++(1) in 2007, whereas bison(1)
    //  / POSIX yacc(1) were limited to type unsafe %union mechanism...
    %polymorphic                STRING: std::string; NUMBER: int;

    // Parser will verify that the polymorphic tag used when calling semantic
    //  value's get() method matches the actual tag of the semantic value...
    %tag-mismatches             on

    // Terminal tokens without associativity or precedence...
    %token
        AGENT
        APPLY_COUNT
        CREATE_UNIT
        DAY
        END_RULE
        EVENT_FAIL
        EVENT_SUCCESS
        EVENT_TYPE_ALERT
        EVENT_TYPE_AUDIO
        EVENT_TYPE_EFFECT
        GREATER
        IDENTIFIER
        IN
        MAP
        NUMBER
        OPTION_COUNT
        OPTION_ID
        OPTION_REPEAT_AFTER
        OPTIONS
        OPTION_SEND_TO
        OPTION_SWITCH_TO
        OPTION_VIA
        OUT
        RANDOM
        RATE
        RELATIONAL_GREATER
        RELATIONAL_IS
        SAMPLE
        SCOPE_GLOBAL
        SCOPE_LOCAL
        START_RULE
        TEST
        TIME_TRIGGER

    // For non-terminals whose semantic value can vary, select the underlying 
    //  storage type that makes them easiest to work with...
    %type <STRING>              identifier
    %type <NUMBER>              expression, number

    // Set the starting symboling. After the Bison parser's bottom up algorithm
    //  reduces each previous shift (push of a token or grouping to parser
    //  stack), the final reduction should contain none other than the original
    //  start symbol...
    %start                      input

    // Warn whenever the default action is used for a production rule missing
    //  an explicit semantic...
//    %default-actions            warn

    // Add the standard location stack to the generated parser so we can track
    //  locations...
    %lsp-needed
    
    // Increase the usefulness of error messages passed to the error reporting
    //  function...
    %error-verbose
    
//%no-lines
    
    // Ensure that each thread's polymorphic code is thread safe. All this
    //  effectively does at this time is ensure the parser accesses its error
    //  counter data member in a thread safe manner. Not available until version
    //  6.00.00. In mean time, specify --thread-safe instead for same effect...
    %thread-safe

// Grammar rules section contains machine readable Backus-Naur form with
//  intended actions (semantics) to perform...
%%

input:
    /* empty */
  | input line
  ;

line: 
    '\n'
  | statement '\n'                  { $$ = $1;                              }
  ;

statement:
    expression ';'
  | identifier ';'
  ;

expression:
    number
  | expression '+' expression       { $$ = $1;                              }
  | expression '-' expression       { $$ = $1 - $3;                         }
  | expression '*' expression       { $$ = $1 * $3;                         }
  | expression '/' expression       
    {
        if($3)
            $$ = $1 / $3;
        else
        {
            $$ = 1;
            std::cerr << @3.first_line << ": division by zero" << std::endl;
            ABORT();
        }
    }
  | expression '%' expression       { $$ =   $1 % $3;                       }
  | '-' expression %prec UNARY      { $$ =  -$2;                            }
  | '+' expression %prec UNARY      { $$ =   $2;                            }
  | expression '^' expression       { $$ = static_cast<int>(::pow($1, $3)); }
  | '(' expression ')'              { $$ =   $2;                            }
  ;

identifier:
    IDENTIFIER                      { $$ = d_scanner.matched();             }
  ;

number:
    NUMBER                          { $$ = std::stoi(d_scanner.matched());  }
  ;


